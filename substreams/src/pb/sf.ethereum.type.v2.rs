// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(bytes="vec", tag="2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="3")]
    pub number: u64,
    #[prost(uint64, tag="4")]
    pub size: u64,
    #[prost(message, optional, tag="5")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, repeated, tag="6")]
    pub uncles: ::prost::alloc::vec::Vec<BlockHeader>,
    #[prost(message, repeated, tag="10")]
    pub transaction_traces: ::prost::alloc::vec::Vec<TransactionTrace>,
    #[prost(message, repeated, tag="11")]
    pub balance_changes: ::prost::alloc::vec::Vec<BalanceChange>,
    #[prost(enumeration="block::DetailLevel", tag="12")]
    pub detail_level: i32,
    #[prost(message, repeated, tag="20")]
    pub code_changes: ::prost::alloc::vec::Vec<CodeChange>,
    #[prost(message, repeated, tag="21")]
    pub system_calls: ::prost::alloc::vec::Vec<Call>,
    #[prost(int32, tag="1")]
    pub ver: i32,
}
/// Nested message and enum types in `Block`.
pub mod block {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DetailLevel {
        DetaillevelExtended = 0,
        DetaillevelBase = 2,
    }
    impl DetailLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DetailLevel::DetaillevelExtended => "DETAILLEVEL_EXTENDED",
                DetailLevel::DetaillevelBase => "DETAILLEVEL_BASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DETAILLEVEL_EXTENDED" => Some(Self::DetaillevelExtended),
                "DETAILLEVEL_BASE" => Some(Self::DetaillevelBase),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    #[prost(bytes="vec", tag="1")]
    pub parent_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub uncle_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub coinbase: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="4")]
    pub state_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="5")]
    pub transactions_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="6")]
    pub receipt_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="7")]
    pub logs_bloom: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="8")]
    pub difficulty: ::core::option::Option<BigInt>,
    #[deprecated]
    #[prost(message, optional, tag="17")]
    pub total_difficulty: ::core::option::Option<BigInt>,
    #[prost(uint64, tag="9")]
    pub number: u64,
    #[prost(uint64, tag="10")]
    pub gas_limit: u64,
    #[prost(uint64, tag="11")]
    pub gas_used: u64,
    #[prost(message, optional, tag="12")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bytes="vec", tag="13")]
    pub extra_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="14")]
    pub mix_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="15")]
    pub nonce: u64,
    #[prost(bytes="vec", tag="16")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="18")]
    pub base_fee_per_gas: ::core::option::Option<BigInt>,
    #[prost(bytes="vec", tag="19")]
    pub withdrawals_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="20")]
    pub tx_dependency: ::core::option::Option<Uint64NestedArray>,
    #[prost(uint64, optional, tag="22")]
    pub blob_gas_used: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="23")]
    pub excess_blob_gas: ::core::option::Option<u64>,
    #[prost(bytes="vec", tag="24")]
    pub parent_beacon_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="25")]
    pub requests_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uint64NestedArray {
    #[prost(message, repeated, tag="1")]
    pub val: ::prost::alloc::vec::Vec<Uint64Array>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uint64Array {
    #[prost(uint64, repeated, tag="1")]
    pub val: ::prost::alloc::vec::Vec<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigInt {
    #[prost(bytes="vec", tag="1")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionTrace {
    #[prost(bytes="vec", tag="1")]
    pub to: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="2")]
    pub nonce: u64,
    #[prost(message, optional, tag="3")]
    pub gas_price: ::core::option::Option<BigInt>,
    #[prost(uint64, tag="4")]
    pub gas_limit: u64,
    #[prost(message, optional, tag="5")]
    pub value: ::core::option::Option<BigInt>,
    #[prost(bytes="vec", tag="6")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="7")]
    pub v: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="8")]
    pub r: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="9")]
    pub s: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="10")]
    pub gas_used: u64,
    #[prost(enumeration="transaction_trace::Type", tag="12")]
    pub r#type: i32,
    #[prost(message, repeated, tag="14")]
    pub access_list: ::prost::alloc::vec::Vec<AccessTuple>,
    #[prost(message, optional, tag="11")]
    pub max_fee_per_gas: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="13")]
    pub max_priority_fee_per_gas: ::core::option::Option<BigInt>,
    #[prost(uint32, tag="20")]
    pub index: u32,
    #[prost(bytes="vec", tag="21")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="22")]
    pub from: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="23")]
    pub return_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="24")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="25")]
    pub begin_ordinal: u64,
    #[prost(uint64, tag="26")]
    pub end_ordinal: u64,
    #[prost(enumeration="TransactionTraceStatus", tag="30")]
    pub status: i32,
    #[prost(message, optional, tag="31")]
    pub receipt: ::core::option::Option<TransactionReceipt>,
    #[prost(message, repeated, tag="32")]
    pub calls: ::prost::alloc::vec::Vec<Call>,
    #[prost(uint64, optional, tag="33")]
    pub blob_gas: ::core::option::Option<u64>,
    #[prost(message, optional, tag="34")]
    pub blob_gas_fee_cap: ::core::option::Option<BigInt>,
    #[prost(bytes="vec", repeated, tag="35")]
    pub blob_hashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag="36")]
    pub set_code_authorizations: ::prost::alloc::vec::Vec<SetCodeAuthorization>,
}
/// Nested message and enum types in `TransactionTrace`.
pub mod transaction_trace {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        TrxTypeLegacy = 0,
        TrxTypeAccessList = 1,
        TrxTypeDynamicFee = 2,
        TrxTypeBlob = 3,
        TrxTypeSetCode = 4,
        TrxTypeArbitrumDeposit = 100,
        TrxTypeArbitrumUnsigned = 101,
        TrxTypeArbitrumContract = 102,
        TrxTypeArbitrumRetry = 104,
        TrxTypeArbitrumSubmitRetryable = 105,
        TrxTypeArbitrumInternal = 106,
        TrxTypeArbitrumLegacy = 120,
        TrxTypeOptimismDeposit = 126,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::TrxTypeLegacy => "TRX_TYPE_LEGACY",
                Type::TrxTypeAccessList => "TRX_TYPE_ACCESS_LIST",
                Type::TrxTypeDynamicFee => "TRX_TYPE_DYNAMIC_FEE",
                Type::TrxTypeBlob => "TRX_TYPE_BLOB",
                Type::TrxTypeSetCode => "TRX_TYPE_SET_CODE",
                Type::TrxTypeArbitrumDeposit => "TRX_TYPE_ARBITRUM_DEPOSIT",
                Type::TrxTypeArbitrumUnsigned => "TRX_TYPE_ARBITRUM_UNSIGNED",
                Type::TrxTypeArbitrumContract => "TRX_TYPE_ARBITRUM_CONTRACT",
                Type::TrxTypeArbitrumRetry => "TRX_TYPE_ARBITRUM_RETRY",
                Type::TrxTypeArbitrumSubmitRetryable => "TRX_TYPE_ARBITRUM_SUBMIT_RETRYABLE",
                Type::TrxTypeArbitrumInternal => "TRX_TYPE_ARBITRUM_INTERNAL",
                Type::TrxTypeArbitrumLegacy => "TRX_TYPE_ARBITRUM_LEGACY",
                Type::TrxTypeOptimismDeposit => "TRX_TYPE_OPTIMISM_DEPOSIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRX_TYPE_LEGACY" => Some(Self::TrxTypeLegacy),
                "TRX_TYPE_ACCESS_LIST" => Some(Self::TrxTypeAccessList),
                "TRX_TYPE_DYNAMIC_FEE" => Some(Self::TrxTypeDynamicFee),
                "TRX_TYPE_BLOB" => Some(Self::TrxTypeBlob),
                "TRX_TYPE_SET_CODE" => Some(Self::TrxTypeSetCode),
                "TRX_TYPE_ARBITRUM_DEPOSIT" => Some(Self::TrxTypeArbitrumDeposit),
                "TRX_TYPE_ARBITRUM_UNSIGNED" => Some(Self::TrxTypeArbitrumUnsigned),
                "TRX_TYPE_ARBITRUM_CONTRACT" => Some(Self::TrxTypeArbitrumContract),
                "TRX_TYPE_ARBITRUM_RETRY" => Some(Self::TrxTypeArbitrumRetry),
                "TRX_TYPE_ARBITRUM_SUBMIT_RETRYABLE" => Some(Self::TrxTypeArbitrumSubmitRetryable),
                "TRX_TYPE_ARBITRUM_INTERNAL" => Some(Self::TrxTypeArbitrumInternal),
                "TRX_TYPE_ARBITRUM_LEGACY" => Some(Self::TrxTypeArbitrumLegacy),
                "TRX_TYPE_OPTIMISM_DEPOSIT" => Some(Self::TrxTypeOptimismDeposit),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessTuple {
    #[prost(bytes="vec", tag="1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", repeated, tag="2")]
    pub storage_keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCodeAuthorization {
    #[prost(bool, tag="1")]
    pub discarded: bool,
    #[prost(bytes="vec", tag="2")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="8")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="3")]
    pub nonce: u64,
    #[prost(uint32, tag="4")]
    pub v: u32,
    #[prost(bytes="vec", tag="5")]
    pub r: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="6")]
    pub s: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", optional, tag="7")]
    pub authority: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionReceipt {
    #[prost(bytes="vec", tag="1")]
    pub state_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="2")]
    pub cumulative_gas_used: u64,
    #[prost(bytes="vec", tag="3")]
    pub logs_bloom: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag="4")]
    pub logs: ::prost::alloc::vec::Vec<Log>,
    #[prost(uint64, optional, tag="5")]
    pub blob_gas_used: ::core::option::Option<u64>,
    #[prost(message, optional, tag="6")]
    pub blob_gas_price: ::core::option::Option<BigInt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Log {
    #[prost(bytes="vec", tag="1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", repeated, tag="2")]
    pub topics: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", tag="3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag="4")]
    pub index: u32,
    #[prost(uint32, tag="6")]
    pub block_index: u32,
    #[prost(uint64, tag="7")]
    pub ordinal: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Call {
    #[prost(uint32, tag="1")]
    pub index: u32,
    #[prost(uint32, tag="2")]
    pub parent_index: u32,
    #[prost(uint32, tag="3")]
    pub depth: u32,
    #[prost(enumeration="CallType", tag="4")]
    pub call_type: i32,
    #[prost(bytes="vec", tag="5")]
    pub caller: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="6")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", optional, tag="34")]
    pub address_delegates_to: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="7")]
    pub value: ::core::option::Option<BigInt>,
    #[prost(uint64, tag="8")]
    pub gas_limit: u64,
    #[prost(uint64, tag="9")]
    pub gas_consumed: u64,
    #[prost(bytes="vec", tag="13")]
    pub return_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="14")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag="15")]
    pub executed_code: bool,
    #[prost(bool, tag="16")]
    pub suicide: bool,
    #[prost(map="string, string", tag="20")]
    pub keccak_preimages: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, repeated, tag="21")]
    pub storage_changes: ::prost::alloc::vec::Vec<StorageChange>,
    #[prost(message, repeated, tag="22")]
    pub balance_changes: ::prost::alloc::vec::Vec<BalanceChange>,
    #[prost(message, repeated, tag="24")]
    pub nonce_changes: ::prost::alloc::vec::Vec<NonceChange>,
    #[prost(message, repeated, tag="25")]
    pub logs: ::prost::alloc::vec::Vec<Log>,
    #[prost(message, repeated, tag="26")]
    pub code_changes: ::prost::alloc::vec::Vec<CodeChange>,
    #[prost(message, repeated, tag="28")]
    pub gas_changes: ::prost::alloc::vec::Vec<GasChange>,
    #[prost(bool, tag="10")]
    pub status_failed: bool,
    #[prost(bool, tag="12")]
    pub status_reverted: bool,
    #[prost(string, tag="11")]
    pub failure_reason: ::prost::alloc::string::String,
    #[prost(bool, tag="30")]
    pub state_reverted: bool,
    #[prost(uint64, tag="31")]
    pub begin_ordinal: u64,
    #[prost(uint64, tag="32")]
    pub end_ordinal: u64,
    #[deprecated]
    #[prost(message, repeated, tag="33")]
    pub account_creations: ::prost::alloc::vec::Vec<AccountCreation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageChange {
    #[prost(bytes="vec", tag="1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub old_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="4")]
    pub new_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="5")]
    pub ordinal: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceChange {
    #[prost(bytes="vec", tag="1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="2")]
    pub old_value: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="3")]
    pub new_value: ::core::option::Option<BigInt>,
    #[prost(enumeration="balance_change::Reason", tag="4")]
    pub reason: i32,
    #[prost(uint64, tag="5")]
    pub ordinal: u64,
}
/// Nested message and enum types in `BalanceChange`.
pub mod balance_change {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Reason {
        Unknown = 0,
        RewardMineUncle = 1,
        RewardMineBlock = 2,
        DaoRefundContract = 3,
        DaoAdjustBalance = 4,
        Transfer = 5,
        GenesisBalance = 6,
        GasBuy = 7,
        RewardTransactionFee = 8,
        RewardFeeReset = 14,
        GasRefund = 9,
        TouchAccount = 10,
        SuicideRefund = 11,
        SuicideWithdraw = 13,
        CallBalanceOverride = 12,
        Burn = 15,
        Withdrawal = 16,
        RewardBlobFee = 17,
        IncreaseMint = 18,
        Revert = 19,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reason::Unknown => "REASON_UNKNOWN",
                Reason::RewardMineUncle => "REASON_REWARD_MINE_UNCLE",
                Reason::RewardMineBlock => "REASON_REWARD_MINE_BLOCK",
                Reason::DaoRefundContract => "REASON_DAO_REFUND_CONTRACT",
                Reason::DaoAdjustBalance => "REASON_DAO_ADJUST_BALANCE",
                Reason::Transfer => "REASON_TRANSFER",
                Reason::GenesisBalance => "REASON_GENESIS_BALANCE",
                Reason::GasBuy => "REASON_GAS_BUY",
                Reason::RewardTransactionFee => "REASON_REWARD_TRANSACTION_FEE",
                Reason::RewardFeeReset => "REASON_REWARD_FEE_RESET",
                Reason::GasRefund => "REASON_GAS_REFUND",
                Reason::TouchAccount => "REASON_TOUCH_ACCOUNT",
                Reason::SuicideRefund => "REASON_SUICIDE_REFUND",
                Reason::SuicideWithdraw => "REASON_SUICIDE_WITHDRAW",
                Reason::CallBalanceOverride => "REASON_CALL_BALANCE_OVERRIDE",
                Reason::Burn => "REASON_BURN",
                Reason::Withdrawal => "REASON_WITHDRAWAL",
                Reason::RewardBlobFee => "REASON_REWARD_BLOB_FEE",
                Reason::IncreaseMint => "REASON_INCREASE_MINT",
                Reason::Revert => "REASON_REVERT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNKNOWN" => Some(Self::Unknown),
                "REASON_REWARD_MINE_UNCLE" => Some(Self::RewardMineUncle),
                "REASON_REWARD_MINE_BLOCK" => Some(Self::RewardMineBlock),
                "REASON_DAO_REFUND_CONTRACT" => Some(Self::DaoRefundContract),
                "REASON_DAO_ADJUST_BALANCE" => Some(Self::DaoAdjustBalance),
                "REASON_TRANSFER" => Some(Self::Transfer),
                "REASON_GENESIS_BALANCE" => Some(Self::GenesisBalance),
                "REASON_GAS_BUY" => Some(Self::GasBuy),
                "REASON_REWARD_TRANSACTION_FEE" => Some(Self::RewardTransactionFee),
                "REASON_REWARD_FEE_RESET" => Some(Self::RewardFeeReset),
                "REASON_GAS_REFUND" => Some(Self::GasRefund),
                "REASON_TOUCH_ACCOUNT" => Some(Self::TouchAccount),
                "REASON_SUICIDE_REFUND" => Some(Self::SuicideRefund),
                "REASON_SUICIDE_WITHDRAW" => Some(Self::SuicideWithdraw),
                "REASON_CALL_BALANCE_OVERRIDE" => Some(Self::CallBalanceOverride),
                "REASON_BURN" => Some(Self::Burn),
                "REASON_WITHDRAWAL" => Some(Self::Withdrawal),
                "REASON_REWARD_BLOB_FEE" => Some(Self::RewardBlobFee),
                "REASON_INCREASE_MINT" => Some(Self::IncreaseMint),
                "REASON_REVERT" => Some(Self::Revert),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NonceChange {
    #[prost(bytes="vec", tag="1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="2")]
    pub old_value: u64,
    #[prost(uint64, tag="3")]
    pub new_value: u64,
    #[prost(uint64, tag="4")]
    pub ordinal: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountCreation {
    #[prost(bytes="vec", tag="1")]
    pub account: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="2")]
    pub ordinal: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodeChange {
    #[prost(bytes="vec", tag="1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub old_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub old_code: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="4")]
    pub new_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="5")]
    pub new_code: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="6")]
    pub ordinal: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GasChange {
    #[prost(uint64, tag="1")]
    pub old_value: u64,
    #[prost(uint64, tag="2")]
    pub new_value: u64,
    #[prost(enumeration="gas_change::Reason", tag="3")]
    pub reason: i32,
    #[prost(uint64, tag="4")]
    pub ordinal: u64,
}
/// Nested message and enum types in `GasChange`.
pub mod gas_change {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Reason {
        Unknown = 0,
        Call = 1,
        CallCode = 2,
        CallDataCopy = 3,
        CodeCopy = 4,
        CodeStorage = 5,
        ContractCreation = 6,
        ContractCreation2 = 7,
        DelegateCall = 8,
        EventLog = 9,
        ExtCodeCopy = 10,
        FailedExecution = 11,
        IntrinsicGas = 12,
        PrecompiledContract = 13,
        RefundAfterExecution = 14,
        Return = 15,
        ReturnDataCopy = 16,
        Revert = 17,
        SelfDestruct = 18,
        StaticCall = 19,
        StateColdAccess = 20,
        TxInitialBalance = 21,
        TxRefunds = 22,
        TxLeftOverReturned = 23,
        CallInitialBalance = 24,
        CallLeftOverReturned = 25,
        WitnessContractInit = 26,
        WitnessContractCreation = 27,
        WitnessCodeChunk = 28,
        WitnessContractCollisionCheck = 29,
        TxDataFloor = 30,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reason::Unknown => "REASON_UNKNOWN",
                Reason::Call => "REASON_CALL",
                Reason::CallCode => "REASON_CALL_CODE",
                Reason::CallDataCopy => "REASON_CALL_DATA_COPY",
                Reason::CodeCopy => "REASON_CODE_COPY",
                Reason::CodeStorage => "REASON_CODE_STORAGE",
                Reason::ContractCreation => "REASON_CONTRACT_CREATION",
                Reason::ContractCreation2 => "REASON_CONTRACT_CREATION2",
                Reason::DelegateCall => "REASON_DELEGATE_CALL",
                Reason::EventLog => "REASON_EVENT_LOG",
                Reason::ExtCodeCopy => "REASON_EXT_CODE_COPY",
                Reason::FailedExecution => "REASON_FAILED_EXECUTION",
                Reason::IntrinsicGas => "REASON_INTRINSIC_GAS",
                Reason::PrecompiledContract => "REASON_PRECOMPILED_CONTRACT",
                Reason::RefundAfterExecution => "REASON_REFUND_AFTER_EXECUTION",
                Reason::Return => "REASON_RETURN",
                Reason::ReturnDataCopy => "REASON_RETURN_DATA_COPY",
                Reason::Revert => "REASON_REVERT",
                Reason::SelfDestruct => "REASON_SELF_DESTRUCT",
                Reason::StaticCall => "REASON_STATIC_CALL",
                Reason::StateColdAccess => "REASON_STATE_COLD_ACCESS",
                Reason::TxInitialBalance => "REASON_TX_INITIAL_BALANCE",
                Reason::TxRefunds => "REASON_TX_REFUNDS",
                Reason::TxLeftOverReturned => "REASON_TX_LEFT_OVER_RETURNED",
                Reason::CallInitialBalance => "REASON_CALL_INITIAL_BALANCE",
                Reason::CallLeftOverReturned => "REASON_CALL_LEFT_OVER_RETURNED",
                Reason::WitnessContractInit => "REASON_WITNESS_CONTRACT_INIT",
                Reason::WitnessContractCreation => "REASON_WITNESS_CONTRACT_CREATION",
                Reason::WitnessCodeChunk => "REASON_WITNESS_CODE_CHUNK",
                Reason::WitnessContractCollisionCheck => "REASON_WITNESS_CONTRACT_COLLISION_CHECK",
                Reason::TxDataFloor => "REASON_TX_DATA_FLOOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNKNOWN" => Some(Self::Unknown),
                "REASON_CALL" => Some(Self::Call),
                "REASON_CALL_CODE" => Some(Self::CallCode),
                "REASON_CALL_DATA_COPY" => Some(Self::CallDataCopy),
                "REASON_CODE_COPY" => Some(Self::CodeCopy),
                "REASON_CODE_STORAGE" => Some(Self::CodeStorage),
                "REASON_CONTRACT_CREATION" => Some(Self::ContractCreation),
                "REASON_CONTRACT_CREATION2" => Some(Self::ContractCreation2),
                "REASON_DELEGATE_CALL" => Some(Self::DelegateCall),
                "REASON_EVENT_LOG" => Some(Self::EventLog),
                "REASON_EXT_CODE_COPY" => Some(Self::ExtCodeCopy),
                "REASON_FAILED_EXECUTION" => Some(Self::FailedExecution),
                "REASON_INTRINSIC_GAS" => Some(Self::IntrinsicGas),
                "REASON_PRECOMPILED_CONTRACT" => Some(Self::PrecompiledContract),
                "REASON_REFUND_AFTER_EXECUTION" => Some(Self::RefundAfterExecution),
                "REASON_RETURN" => Some(Self::Return),
                "REASON_RETURN_DATA_COPY" => Some(Self::ReturnDataCopy),
                "REASON_REVERT" => Some(Self::Revert),
                "REASON_SELF_DESTRUCT" => Some(Self::SelfDestruct),
                "REASON_STATIC_CALL" => Some(Self::StaticCall),
                "REASON_STATE_COLD_ACCESS" => Some(Self::StateColdAccess),
                "REASON_TX_INITIAL_BALANCE" => Some(Self::TxInitialBalance),
                "REASON_TX_REFUNDS" => Some(Self::TxRefunds),
                "REASON_TX_LEFT_OVER_RETURNED" => Some(Self::TxLeftOverReturned),
                "REASON_CALL_INITIAL_BALANCE" => Some(Self::CallInitialBalance),
                "REASON_CALL_LEFT_OVER_RETURNED" => Some(Self::CallLeftOverReturned),
                "REASON_WITNESS_CONTRACT_INIT" => Some(Self::WitnessContractInit),
                "REASON_WITNESS_CONTRACT_CREATION" => Some(Self::WitnessContractCreation),
                "REASON_WITNESS_CODE_CHUNK" => Some(Self::WitnessCodeChunk),
                "REASON_WITNESS_CONTRACT_COLLISION_CHECK" => Some(Self::WitnessContractCollisionCheck),
                "REASON_TX_DATA_FLOOR" => Some(Self::TxDataFloor),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeaderOnlyBlock {
    #[prost(message, optional, tag="5")]
    pub header: ::core::option::Option<BlockHeader>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockWithRefs {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub block: ::core::option::Option<Block>,
    #[prost(message, optional, tag="3")]
    pub transaction_trace_refs: ::core::option::Option<TransactionRefs>,
    #[prost(bool, tag="4")]
    pub irreversible: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionTraceWithBlockRef {
    #[prost(message, optional, tag="1")]
    pub trace: ::core::option::Option<TransactionTrace>,
    #[prost(message, optional, tag="2")]
    pub block_ref: ::core::option::Option<BlockRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionRefs {
    #[prost(bytes="vec", repeated, tag="1")]
    pub hashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRef {
    #[prost(bytes="vec", tag="1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="2")]
    pub number: u64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionTraceStatus {
    Unknown = 0,
    Succeeded = 1,
    Failed = 2,
    Reverted = 3,
}
impl TransactionTraceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionTraceStatus::Unknown => "UNKNOWN",
            TransactionTraceStatus::Succeeded => "SUCCEEDED",
            TransactionTraceStatus::Failed => "FAILED",
            TransactionTraceStatus::Reverted => "REVERTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "SUCCEEDED" => Some(Self::Succeeded),
            "FAILED" => Some(Self::Failed),
            "REVERTED" => Some(Self::Reverted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallType {
    Unspecified = 0,
    Call = 1,
    Callcode = 2,
    Delegate = 3,
    Static = 4,
    Create = 5,
}
impl CallType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CallType::Unspecified => "UNSPECIFIED",
            CallType::Call => "CALL",
            CallType::Callcode => "CALLCODE",
            CallType::Delegate => "DELEGATE",
            CallType::Static => "STATIC",
            CallType::Create => "CREATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "CALL" => Some(Self::Call),
            "CALLCODE" => Some(Self::Callcode),
            "DELEGATE" => Some(Self::Delegate),
            "STATIC" => Some(Self::Static),
            "CREATE" => Some(Self::Create),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
